Models:
User: has_many_routines, has_many products through routines
Routine: belongs to user, has many instructions, has many products
Product - Belongs to routine, has many user through routine

Have a user have a list of products

Tables:

User:
- t.string :username
- t.string :email address
- t.string :password_digest

Routines:
- t.string :name
- t.string :description 
- t.text :products (a collection of products used in the routine) (will try to use erb tags + OL to list out the products in order)
- t.integer :user_id -> (foreign key to associate with user)

Products:
- t.string :name
- t.string :category
- t.integer :routine_id (associates a product to a routine)


Views
- Routines
   - new.erb
   - edit.erb
   - show.erb
   - routines.erb

- Users
   - new_user.erb
   - login.erb
   - show.erb


- A routine belongs to a user
- You can't have a product belong to an instruction unless you want a bunch of duplicate products (this is ok, confirmed with Micah)
- Make the products resuable 
- Routine belongs to user 


- Each user has a routine, each routine has instructions 
- Could make instruction part of the products Tables:
- Routine id, product id, 

- Table InstructionJoin table between Instructions and routines

Join table 
Routine ID, Instruction ID, Step in Routine 
Validate uniqueness of instruction



User Interface
- Want to allow user to sign up/login ('/signup', '/login')
   - By signing up, I'm creating a new user
   - By logging in, I'm creating a new session
- Index Page to welcome user - DONE
- Create user in DB and Model - DONE
- Want to allow user to create new routine / persist routine to database - DONE
- Set up CSS - done

Sessions: What allow us to handle user authentication and authorization - DONE
   - When we enable session + set an appropriate key, we get a hash
   - We can write info into that hash, hash will be persisted via sending cookies to user to live in web browser
   - cookies are secured + encrypted, signed with session secret key -> any info sent to browser is unreadable and unable to be changed


To-do's:

--- do products.all helper method ---

def all_products
   return self.products.all 
end

def current_routine 

end


Priorities 
- Need to protect product form being able to pass blank values
- Have a user be able to delete a product from a routine, but keep the product in product index


FINISHED TASKS
- Post users routines on index page (may not be able to do this w partial - needs to show routine.name of each routine) - DONE
- User needs to be able to create routine, then be redirect to their index of routines - DONE
- Routine edit action - DONE
- Routine Delete Action - DONE
- products associating with routines - DONE
- ....need to get routine_products to associate with user - DONE
- Routine show View (needs to be an ordered list with clickable link to each product) - DONE
- . Product view index - want user to be able to see the products associated with routines THEY'VE made - DONE
- Want user to be able to click on a product in that index and open its description (show) - DONE
- User routine displays products acssociated with it 
- Want user to be able to create new product thru the UI - done, but need to finish #2 as well - DONE
- Want user to be able to add product to existing routine (can do on backend, need to do in PC) - DONE
- Error page for bad url's  - DONE
- Finish blog post - DONE
- Edit Product action - DONE

User flow
1. Sign up/login - done
2. User homepage: "Hey user, here are a list of your most recent routines (each routine is clickable)
3. There's a menu up top with "home", "routines", "products"
   - Home is just homepage 
   - Routines is an index of all their routines
   - Products is a repo of products in the database + their descriptions (links are clickable, products can be individually added to a routine)


   Knowledge Requirements:

   1. How do you enable sessions? 
      ApplicationController -> enable :sessions, set :session_secret
   - A session is a way for a web app to set a cookie that persists accross multiple HTTP requests + relate these requests to eachother
   - If you do something in an app and that something is stored to your session, the web app can use it later
   - Session secret is a secret key for encrypting these cookies, proctecting the server from being accessed

   2. How do you set up a database? 
   - Install sqlite3
  
   
   3. How do you ensure all your gems are being used? 
   - Check the gemfile, then check the gemfile lock. If not in the gefile lock, run bundle install to get up to date.

   4. What gem enables password encryption?
   - bcrypt 

   5. How do we encrypt our passwords in the database?
   - with bcrypt, which a password hashing function
   - If using bcrypt, when creating your migration, set the password attribute as :password_digest. 
   - bcrypt will automatically encypt what's passed thru as the password
   - To authenticate a user, the password presented by the user is hashed and compared with the stored hash
   - A password hash requires the use of a large random, non-secret salt value which can be stored with the password hash. 
   - The salt randomizes the output of the password hash, making it impossible to guess.
  

   6. What are helpers and why do we use them?
   - A helper is a method that is used to perform a repetitive task common across multiple classes. 
   - It keeps us from repeating the same code in different classes, making our application more dry.

   7. How do you make helpers?
   - in the ApplicationController file, open up a block and place the methods inside. 

      helpers do 

         def helper_method do
            ...
         end

      end

   8. How do you create a migration?
    - With ActiveRecord
      1. rake db:create_migration NAME = create_table
      2. in the migration file, create the table, add its data type and attribute names
      3. run rake db:migrate

   9. How you you set up a has_many and belongs_to relationship vs a has_many to has_many in SQL/ActiveRecord?
   - You set them up in your models. The "parent" model has_many of whatever you're trying to create a relationship with. 
   - The "child Model" belongs to the parent :
   ex. A User has_many Routines, a Routine belongs to a User

   10. How do you rescue an error in ruby?
   - by raising an exception error to prevent the app from crashing.

   11. What is the difference between authentication and authorization?
   - Authentication: verifies the identity of the user and grants them access to the resource. (a log in page)
   - Authorization: Makes sure that the user has the needed level of clearance to get a specific resource (validating credentials via passwords etc.).

   12.
   
   13. What is rack?
   - Rack is a ruby gem that allows us to create a simple web server. Rails is built on top of rack.
   - Rack's primary purposes is to serve as middleware for the Ruby server and frameworks (sinatra) to work together


   14. What is Rake used for? How do you make a Rake task?
   - Rake is used to run tasks in Rails applications (ex. Rake Console, Rake db:migrate)
   - Makes a backup of the database, runs tests, and centralizes tasks
   - Can also create custom tasks in your application

   15. How do you use a .gitignore file correctly?

   16. What methods does ActiveRecord give you? How do you access associations?
   - Be able to show Micah in Rake Console







   
