Models:
User: has_many_routines, has_many products through routines
Routine: belongs to user, has many instructions, has many products
Product - Belongs to routine, has many user through routine

Have a user have a list of products

Tables:

User:
- t.string :username
- t.string :email address
- t.string :password_digest

Routines:
- t.string :name
- t.string :description 
- t.text :products (a collection of products used in the routine) (will try to use erb tags + OL to list out the products in order)
- t.integer :user_id -> (foreign key to associate with user)

Products:
- t.string :name
- t.string :category
- t.integer :routine_id (associates a product to a routine)


Views
- Routines
   - new.erb
   - edit.erb
   - show.erb
   - routines.erb

- Users
   - new_user.erb
   - login.erb
   - show.erb


- A routine belongs to a user
- You can't have a product belong to an instruction unless you want a bunch of duplicate products (this is ok, confirmed with Micah)
- Make the products resuable 
- Routine belongs to user 


- Each user has a routine, each routine has instructions 
- Could make instruction part of the products Tables:
- Routine id, product id, 

- Table InstructionJoin table between Instructions and routines

Join table 
Routine ID, Instruction ID, Step in Routine 
Validate uniqueness of instruction



User Interface
- Want to allow user to sign up/login ('/signup', '/login')
   - By signing up, I'm creating a new user
   - By logging in, I'm creating a new session
- Index Page to welcome user - DONE
- Create user in DB and Model - DONE
- Want to allow user to create new routine / persist routine to database - DONE
- Set up CSS - done

Sessions: What allow us to handle user authentication and authorization - DONE
   - When we enable session + set an appropriate key, we get a hash
   - We can write info into that hash, hash will be persisted via sending cookies to user to live in web browser
   - cookies are secured + encrypted, signed with session secret key -> any info sent to browser is unreadable and unable to be changed


To-do's:

--- do products.all helper method ---

def all_products
   return self.products.all 
end

def current_routine 

end


Priorities 
- Have a user be able to delete a product from a routine, but keep the product in product index


FINISHED TASKS
- Post users routines on index page (may not be able to do this w partial - needs to show routine.name of each routine) - DONE
- User needs to be able to create routine, then be redirect to their index of routines - DONE
- Routine edit action - DONE
- Routine Delete Action - DONE
- products associating with routines - DONE
- ....need to get routine_products to associate with user - DONE
- Routine show View (needs to be an ordered list with clickable link to each product) - DONE
- . Product view index - want user to be able to see the products associated with routines THEY'VE made - DONE
- Want user to be able to click on a product in that index and open its description (show) - DONE
- User routine displays products acssociated with it 
- Want user to be able to create new product thru the UI - done, but need to finish #2 as well - DONE
- Want user to be able to add product to existing routine (can do on backend, need to do in PC) - DONE
- Error page for bad url's  - DONE
- Finish blog post - DONE
- Edit Product action - DONE
- Need to protect product form being able to pass blank values - DONE
_____________________________________________________________________________________________________________________

User flow
1. Sign up/login - done
2. User homepage: "Hey user, here are a list of your most recent routines (each routine is clickable)
3. There's a menu up top with "home", "routines", "products"
   - Home is just homepage 
   - Routines is an index of all their routines
   - Products is a repo of products in the database + their descriptions (links are clickable, products can be individually added to a routine)
_____________________________________________________________________________________________________________________ 

   Knowledge Requirements:

   MVC: 
      - What is MVC? 
      - A software design pattern consisting of three components:
         1. Model - The data
         2. View - Interface that displays and modifies data
         3. COntroller - Controls the flow of your program with different operations. Provides model data to the view

      We use MVC because:
      1. it separates files + their responsibilities, which makes the overall program easier to scale and maintain.
      2. Makes the code less buggy
      
      - Models can be re-used in multiple views

   CRUD:
      CRUD represents the 4 basic functions that are inplemented in relational database apps. 
      - Create: creating a new instance of a model
      - Read: sending back information of an instance of a model to the browser/interpreter
      - Update: change an instance of a model's information
      - Delete: remove an instance of a model

   REST
      REST - Representational State Transfer 
      - A software architecture style that we use when designing URL routes on the server.
      - Are "stateless" - meaning that the server does not need to know anything about what state the client is in.
      - Separate concern of the client and server
      - Websites don't HAVE to do this work. More like a set of guidelines.

      RESTful routes and associated actions:
         GET - retrieve a resource (by id) or a collection of resources
         POST - create a new resource
         PATCH - update an existing resource (by id)
         DELETE - Delete a specific resource by id
   
   Sessions/Cookies 
       Sessions/Cookies 
      1. What are sessions?
         - A collection of data stored on the server and associated with a given user (typically via a cookie with an id code)

      2. What are cookies?
         - A small piece of data that a server sends to the user's web browser. The browser may store it and send it back with the next request to the same server. 
         - Typically, it's used to tell if two requests came from the same browser â€” keeping a user logged-in, for example.
           
      3. We use them in our program to determine the session id and browse form page to page during a session without having to log in every page we try to visit.
         - Anything the server needs to remember about the current session is why we use a cookie



   Environment Variables
      1. What are they? 
       
       - Saved in our operating system rather than in our ruby progam 

      2. Why do we use them?
      - To store Variables that can change or that we want to keep secret so that it's hosted on our computer rather than being programmed inside the code itself (ex. the session secret)
      - Authentication keys, Execution mode ie. Development, staging etc, API URLs
      


   1. How do you enable sessions? 
      ApplicationController -> enable :sessions, set :session_secret
   - A session is a way for a web app to set a cookie that persists accross multiple HTTP requests + relate these requests to eachother
   - If you do something in an app and that something is stored to your session, the web app can use it later
   - Session secret is a secret key for encrypting these cookies, proctecting the server from being accessed

   2. How do you set up a database? 
      1. install sqlite3
      2. rake db:create_migration NAME = create_table
      3. in the migration file, create the table, add its data type and attribute names
      4. run rake db:migrate
  
   
   3. How do you ensure all your gems are being used? 
   - Check the gemfile, then check the gemfile lock. If not in the gefile lock, run bundle install to get up to date.

   4. What gem enables password encryption?
   - bcrypt 

   5. How do we encrypt our passwords in the database?
   - with bcrypt, which is a password hashing function
   - If using bcrypt, when creating your migration, set the password attribute as :password_digest. 
   - bcrypt will automatically encypt what's passed thru as the password
   - To authenticate a user, the password presented by the user is hashed and compared with the stored hash
   - A password hash requires the use of a large random, non-secret salt value which can be stored with the password hash. 
   - The salt randomizes the output of the password hash, making it impossible to guess.
  

   6. What are helpers and why do we use them?
   - A helper is a method that is used to perform a repetitive task common across multiple classes. 
   - It keeps us from repeating the same code in different classes, making our application more dry.

   7. How do you make helpers?
   - in the ApplicationController file, open up a block and place the methods inside. 

      helpers do 

         def helper_method do
            ...
         end

      end

   8. How do you create a migration?
    - With ActiveRecord
      1. rake db:create_migration NAME = migration_name
      2. in the migration file, create the table, add its data type and attribute names
      3. run rake db:migrate in terminal to migrate

   9. How you you set up a has_many and belongs_to relationship vs a has_many to has_many in SQL/ActiveRecord?
   - You set them up in your models. The "parent" model has_many of whatever you're trying to create a relationship with. 
   - The "child Model" belongs to the parent
   ex. A User has_many Routines, a Routine belongs to a User

   10. How do you rescue an error in ruby?
   - by raising an exception error to prevent the app from crashing.

   11. What is the difference between authentication and authorization?
   - Authentication: verifies the identity of the user and grants them access to the resource. (a log in page)
   - Authorization: Makes sure that the user has the needed level of clearance to get a specific resource (validating credentials via passwords etc.).

   12.
   
   13. What is rack?
   - Rack is a ruby gem that allows us to create a simple web server. Sinatra is built on top of rack.
   - Rack's primary purposes is to serve as middleware for the Ruby server and frameworks (sinatra) to work together


   14. What is Rake used for? How do you make a Rake task?
   - Rake is used to run tasks in SInatra/Rails applications (ex. Rake Console, Rake db:migrate)
   - Makes a backup of the database, runs tests, and centralizes tasks
   - Can also create custom tasks in your application

   15. How do you use a .gitignore file correctly?
   The purpose of the .gitignore file is to allow you to ignore files, such as editor backup files, build products or local configuration overrides that you never want to commit into a repository. 
   - Without matching .gitignore rules, these files will appear in the "untracked files" section of git status output.
   - THE SESSION SECRET IS IN THE .gitignore FILE SO THAT YOU DO NOT ACCIDENTALLY PUSH YOUR SESSION SECRET TO GITHUB 

   16. What methods does ActiveRecord give you? How do you access associations?
   - Be able to show Micah in Rake Console
   - In terminal, punch in ActiveRecord::Base.methods for list of methods





- want a search bar, type in a product name, return all of the routines with that product in it 

   
